Sorting problem:
Input: A sequence of n numbers.{a1, a2, ..., an}
Output: A permutation {a1', a2', ..., an'} such that a1' <= a2' <= ... <= an'.

The merge procedure assumes that A[startIndex .. mid] and A[mid + 1 .. endIndex] are already sorted.

Merge(A, startIndex, mid, endIndex)
1  - if A[mid] <= A[mid + 1]													// c1
2  -		return
3  - i = startIndex																// c2				
4  - j = mid + 1                                                        		// c3
5  - temp[endIndex - startIndex + 1] 											// c4
6  - index = 0 																	// c5
7  - while i <= mid and j <= endIndex 											// c6  t1
8  - 	if A[i] <= A[j]															// c7  t1 - 1
9  - 	 	temp[index++] = A[i]												// c8  t1 - 1
10 -		i = i + 1 															// c9  t1 - 1
11 - 	else if A[i] > A[j] 													// c10 t1 - 1
12 - 		temp[index++] = A[j] 												// c11 t1 - 1
13 - 		j = j + 1 															// c12 t1 - 1
14 - for i upto mid 															
15 - 	temp[index++] = A[i]
16 - for j upto endIndex
17 - 	temp[index++] = A[j]
18 - for startIndex upto endIndex													// c' N
19 - 	A[k] = index[k - startIndex]
20 - return

Merge-Sort(A, startIndex, endIndex)
1 - if (endIndex == startIndex)
2 -     return
3 - mid = floor((startIndex + endIndex) / 2)
4 - Merge-Sort(A, startIndex, mid)
5 - Merge-Sort(A, mid + 1, endIndex)
6 - Merge(A, startIndex, mid, endIndex)