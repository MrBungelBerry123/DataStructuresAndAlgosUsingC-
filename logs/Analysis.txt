Sorting problem:
Input: A sequence of n objects {a1, a2, a3, ..., an}.
Output: A permutation {a1', a2', a3', ..., an'} such that a1' <= a2' <= a3' <= ... <= an'.

Insertion-Sort(A)						//Cost    Times
1 - for i = 2 upto A.length				// c1		n
2 - 	key = A[i]						// c2		n - 1
3 - 	j = i - 1 						// c3		n - 1
4 - 	while j > 0 and A[j] > key		// c4		(Summation from i = 2 to n)ti
5 - 		A[j + 1] = A[j]				// c5		(Summation from i = 2 to n)(ti - 1)
6 - 		j = j - 1 					// c6		(Summation from i = 2 to n)(ti - 1)
7 -		A[j + 1] = key 					// c7		n - 1

Best case senario - Array is already sorted.
Worst case senario - Array is sorted in descending order.

Let T(n) denote the total cost of insertion sort, for an input of size n.
T(n) = c1n + (c2 + c3 + c7)(n - 1) + c4 SUM (ti) + c5 SUM (ti - 1) + c6 SUM(ti - 1)

Let S(n) denote the total number of swaps for an input of size n.
S(n) = (Summation from i = 2 to n)si

for best case si = 1 and worst case si = i - 1

Best Case:
S(n) = (Summation from i = 2 to n)1 = (n - 1)

Worst Case:
S(n) = (Summation from i = 2 to n)(i - 1) = n(n - 1)/2

Best Case - O(n)
Worst Case - O(n ^ 2)

Space complexity - O(1)

Selection-Sort(A)						// Cost		Times
1 - for i = 1 upto A.length - 1 		// c1 		n
2 - 	min = i 						// c2 		n - 1
3 - 	for j = i + 1 upto A.length 	// c3 		(Summation from i = 1 to n - 1)ti
4 - 		if A.[j] < A[min] 			// c4		(Summation from i = 1 to n - 1)(ti - 1)
5 - 			min = j 				// c5 		(Summation from i = 1 to n - 1)(ti - 1)
6 -		temp = A[min] 					// c6 		n - 1
7 -		A[min] = A[i] 					// c7		n - 1
8 - 	A[i] = temp 					// c8 		n - 1

Best Case - Array already sorted.
Worst Case - Array not sorted.

ti = n - i

T(n) = c1n + (c2 + c6 + c7 + c8)(n - 1) + c3(n2 - n)/2 + (c4 + c5)(n2 - 3n + 2)/2

c''n^2 <= T(n) <= c'n^2

Best Case - O(n ^ 2)
Worst Case - O(n ^ 2)

S(n) = (Summation from i = 1 to n - 1)si
si = (n - i)

S(n) = (Summation from i = 1 to n - 1)(n - i) = n(n - 1)/2


Merge-Sort:

merge(A, startIndex, mid, endIndex)					// Cost			Times
1 - if A[mid] <= A[mid + 1]							// c1
2 - 	return 										// c2
3 - index = 1 										// c3
4 -	i = startIndex 									// c4
5 - j = mid + 1 									// c5
6 - temp[endIndex - startIndex + 1]                 // c6
7 - while i <= mid and j <= endIndex  				// c7			t
8 - 	if A[i] <= A[j] 							// c8 			t - 1
9 -			temp[index] = A[i] 						// c9 			t - 1
10 -		index = index + 1  						// c10 			t - 1
11 -		i = i + 1 								// c11 			t - 1
12 -	else 										// c12 			t - 1
13 -   		temp[index] = A[j] 						// c13 			t - 1
14 -		index = index + 1 						// c14 			t - 1
15 -		j = j + 1 								// c15 			t - 1
16 - while i <= mid 								// c16 			t1
17 -	temp[index] = A[i] 							// c17 			t1 - 1
18 -	index = index + 1 							// c18 			t1 - 1
19 -	i = i + 1 									// c19 			t1 - 1
20 - while j <= endIndex 							// c20 			t2
21 - 	temp[index] = A[j] 							// c21 			t2 - 1
22 -    j = j + 1 									// c22 			t2 - 1
23 - for k = startIndex upto endIndex 				// c23 			n + 1
24 - 	 A[k] = temp[k - startIndex]  				// c24 			n

split(A, startIndex, endIndex)
1 - if startIndex == endIndex
2 - 	return
3 - mid = (startIndex + endIndex) / 2
4 - split(A, startIndex, mid)
5 - split(A, mid + 1, endIndex)
6 - merge(A, startIndex, mid, endIndex)


Shell-Sort:

InsertionSort(A, gap)
1 - i = gap
2 - while i < A.length
3 - 	key = A[i]
4 -		j = i - gap
5 - 	while j > 0 and A[j] > key
6 -			A[j + gap] = A[j]
7 - 		j = j - gap
8 - 	A[j + gap] = key
3 - 	i = i + gap 

shell-sort(A)
1 - gap = A.length / 2
2 - while gap > 0
3 -		InsertionSort(A, gap)
4 - 	gap = gap / 2


Searching problem.
Input - A sorted list of n objects and a value v.
Output - The index of v in the list if it is found other wise a special value NIL.

BinarySearch(A, t)
1 - left = 1
2 - right = A.length
3 - while left < right
4 - 	mid = (left + right) / 2
5 -		if A[mid] = t
6 -			return mid
7 -		else if A[mid] > t
8 -			right = mid - 1
9 -		else
10 - 		left = mid + 1
11 - return NIL

Time Complexity Analysis
Let n = 2 ^ k

log n <= log n + 1 <= 2log n

Crossover indices:
Input: Two sorted list x and y such that y0 < x0 and yn > xn.
Output: Crosover index i such that xi >= yi and yi+1 >= xi+1

  0  1  2 3
-10 -9 -8 5

crossIndices(x, y, left, right)
1 - if left >= right
2 -		return 1
3 -	mid = (left + right) / 2
4 - if x[mid] >= y[mid] and y[mid + 1] >= x[mid + 1]
5 -		return mid
6 -	if x[left] > y[left] and x[mid] < y[mid]
7 -		return crossIndices(x, y, left, mid)
8 - if x[mid + 1] > y[mid + 1] and x[right] < y[right]
9 - 	return crossIndices(x, y, mid + 1, right)