Heap Data Structure:

A heap is an array of objects which satisfies certain properties.

Operations:
1 - Heapify : Take an ordinary array and convert it into a heap.
2 -	Insert : Insert a key into heap.
3 - Delete : Delete a key from heap.
4 - Minimum : Find the minimum element.

Properties of min heap:
1 - A[2 * i] and A[2 * i + 1] are left and right childs of A[i]. If 2 * i + 1 < n.
2 -	A[0] is the smallest element and the root.
3 - If A[2 * i + 1] exists then A[2 * i] also exists.
4 - Heap is a balanced binary tree.
5 - For every A[i], A[2 * i] >= A[i] and A[2 * i + 1] >= A[i].
6 - If A[2 * i] dosenot exists then A[2 * i + 1] dosenot exists.
7 - If a heap has n elements, then there are logn + 1 levels.

Small elements go up, Big elements go down.

Pseudocode:

Parent(index):
1 - return Floor(index / 2)

Left_Child(index):
1 - return (2 * index)

Right_Child(index):
1 - return (2 * index + 1)

isEmpty():
1 - return currentIndex == 1

Peek():
0 - if not isEmpty() 
1 - 	return Heap[1]

HeapifyAbove(index):
0 - temp = Heap[index]
1 - while index != 1
2 - 	parentIndex = Parent(index)
3 - 	if temp < Heap[parentIndex]
4 -			Heap[Index] = Heap[parentIndex]
5 -			index = parentIndex
6 -		else Break
7 -	heap[index] = temp

HeapifyBelow(index):
1 - temp = Heap[index]
2 - left = Left_Child(index)
3 - while left < currentIndex
4 -		min = Min(Heap[left], Heap[left - 1])
5 -		if Heap[min] < temp
6 -			Heap[index] = Heap[min]
7 -			index = min
8 - 	else break
9 -		left = Left_Child(index)
10-	heap[index] = temp

Insert(Key):
1 - Heap[currentIndex] = key
3 - HeapifAbove(currentIndex)
3 - currentIndex = currentIndex + 1

Delete(index):
1 - if index > Heap.length or index < 1
2 -		return
3 - currentIndex = currentIndex - 1
4 -	temp = Heap[index]
5 -	Heap[index] = Heap[currentIndex]
6 -	if Heap[index] < Heap[Parent(index)]
7 -		heapifyAbove(index)
8 -	else
9 -		heapifyBelow(index)
10-	return temp

pop():
1 - return Delete(0)

Static Members:

Swap(A, i, j):
1 - temp = A[i]
2 - A[i] = A[j]
3 - A[j] = temp

5 10 20 2 6 0 3 -1

Heapify(A):
1 - mid = A.length / 2
2 - while mid > 0
3 -		left = 2 * mid
4 -		while left <= A.length
5 -			max = Max(A[left], A[left + 1])
6 - 		if A[max] > Heap[mid]
7 - 			Swap(A, mid, max)
8 - 			left = max
9 - 		else break
10-			left = 2 * mid
11-		mid = mid - 1

BubbleDown(A, index, end):
1 -	temp = A[index]
2 -	left = LeftChild(index)
3 - while left < end
4 -		max = Max(A[left], A[left + 1])
5 - 	if Heap[max] > temp
6 -			Heap[index] = Heap[max]
7 -			index = max
8 -		else break
9 -		left = leftChild(index)
10-	heap[index] = temp

HeapSort(A):
1 - Heapify(A, A.length)
2 - Swap(A, A[A.length], 1)
2 - for i = A.length  - 1 downto 2
3 -     BubbleDown(A, 1, i)
4 -		Swap(A, A[i], A[1])


// Analysis:
Insertion:
Time Complexity - O(log n)
Space Complexity - O(1)

Deletion:
Time Complexity - O(log n)
Space Complexity - O(1)